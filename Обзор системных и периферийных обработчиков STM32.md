Более подробное описание некоторых системных обработчиков прерываний ядра:
[[SVC_Handler]]
[[PendSV_Handler]]
[[SysTick_Handler]]

Микроконтроллеры STM32 (на базе ядра ARM Cortex-M) используют так называемую **векторную таблицу прерываний**. Эта таблица содержит адреса функций (обработчиков), которые вызываются при возникновении различных событий — как системных (ошибки, таймеры), так и периферийных (GPIO, UART и т.д.).

Ниже описаны ключевые векторы из таблицы, которые вы обязательно встретите в своих проектах на STM32.

---

## Системные прерывания ядра Cortex-M

### `NMI_Handler` — Non-Maskable Interrupt (Немаскируемое прерывание)

Это прерывание **невозможно отключить** — оно всегда активно и служит для обработки **особо критических ситуаций**, таких как:

- сбой питания (PVD),
- защита от внешнего вторжения (например, попытка доступа к запрещённой области),
- ошибка внешнего генератора (в некоторых STM32).

Используется редко, но важно понимать, что оно имеет **высший приоритет**, даже выше HardFault.

---

### `HardFault_Handler` — Обработка критических ошибок

Этот обработчик вызывается при возникновении **фатальных ошибок**, таких как:

- обращение к несуществующему адресу,
- попытка выполнения данных как кода,
- переполнение стека,
- неразрешённое использование памяти.

Если вы видите, что MCU "зависает", и в отладчике вы попадаете в `HardFault_Handler`, значит произошло **необработанное исключение**, и надо искать причину в стеке вызовов.
### Отличие NMI от HardFault :

- **`HardFault`** возникает, когда система **внутренне сталкивается с ошибкой** (например, недопустимый доступ к памяти, деление на ноль и т.д.)
- **`NMI`** вызывается **внешними или аппаратными средствами**, и его **прямо не вызывает сам процессор** в ответ на ошибку исполнения (кроме специальных случаев, как сторожевой таймер)

### `MemManage_Handler` — Memory Management Fault

Вызывается при **ошибке управления памятью**, если в микроконтроллере включён **MPU (Memory Protection Unit)**.

Примеры ситуаций:

- попытка обращения к защищённой области RAM или Flash,
- выполнение кода вне разрешённой области.

По умолчанию MPU отключён в большинстве STM32, поэтому этот обработчик может не вызываться.

---

### `BusFault_Handler` — Ошибка на шине

Это исключение возникает при:

- сбое на системной шине (например, при обращении к недоступному периферийному регистру),
- аппаратном сбое при передаче данных между блоками.

Часто `BusFault` приводит к `HardFault`, если не настроено отдельное срабатывание.

---

### `UsageFault_Handler` — Ошибка использования

Вызывается при попытке:

- деления на ноль,
- выполнения недопустимой инструкции,
- ошибки выравнивания данных (если включено).

Может быть полезен для отладки и защиты от неожиданных операций в коде.

---

### `SVC_Handler` — Supervisor Call

Этот обработчик вызывается при выполнении инструкции `SVC` (Supervisor Call) из программы.

Часто используется в **RTOS (например, FreeRTOS)** для вызова системных функций из пользовательского кода.

---

### `DebugMon_Handler` — Debug Monitor

Обработчик отладочных событий, срабатывает при:

- аппаратной точке останова,
- анализе доступа к памяти (watchpoint),
- другой активной отладке.

Обычно используется только в отладке или при реализации своей системы отладки.

---

### `PendSV_Handler` — Pendable Service for System

Это один из **ключевых обработчиков в FreeRTOS** и других ОС реального времени.

Он вызывается для **переключения контекста** между задачами. Работает с низким приоритетом, чтобы не мешать "быстрым" прерываниям.

---

### `SysTick_Handler` — Системный таймер

Прерывание системного таймера SysTick — происходит с фиксированной частотой (обычно 1 мс). Используется для:

- подсчёта времени,
- реализации задержек,
- работы ОС (тайм-ауты, планировщик задач).

Простейший способ делать что-то «раз в интервал» — использовать `SysTick_Handler`.

---

## Периферийные прерывания STM32

### `WWDG_IRQHandler` — Window Watchdog

Срабатывает, если приложение **не сбросило watchdog в нужное время**. Используется как механизм аварийного восстановления — если программа зависла, микроконтроллер будет автоматически перезапущен (нужно переопределять).

---

### `PVD_PVM_IRQHandler` — Power Voltage Detector

Обнаруживает падение напряжения ниже допустимого уровня. Используется для защиты от сбоев при питании, может инициировать сохранение данных или остановку чувствительной логики.

---

### `RTC_TAMP_LSECSS_IRQHandler`

Объединённое прерывание для:

- **RTC_TAMP** — обнаружение попытки доступа или изменения в RTC (например, отключение батарейки).
- **LSECSS** — сбой в кварцевом генераторе низкой частоты (LSE).

Может использоваться в защищённых устройствах, где нужно отслеживать вмешательство.

---

### `RTC_WKUP_IRQHandler` — RTC Wake-Up

Вызывается, когда **RTC таймер сработал**. Используется для пробуждения из режима сна, таймера событий (например, каждую минуту выполнять задачу).

---

### `FLASH_IRQHandler` — Прерывание контроллера Flash

Прерывание при завершении операций записи или стирания Flash. Используется при:

- асинхронной записи во Flash,
- обнаружении ошибок доступа.

---

### `RCC_IRQHandler` — Reset and Clock Control

Срабатывает при изменении или ошибках в источниках тактирования (например, сбой внешнего кварца).

Можно использовать для восстановления тактирования или переключения на внутренний источник (HSI).

---

### `EXTI0_IRQHandler` — External Interrupt Line 0

Прерывание от внешней линии EXTI0 (обычно соответствует GPIO pin A0). Используется для:

- нажатий кнопок,
- сигналов от датчиков (например, движение, касание),
- событий внешней логики.

Поддерживается до EXTI15, каждый со своим обработчиком.