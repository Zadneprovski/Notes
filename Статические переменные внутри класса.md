
Статические переменные класса в C++ объявляются **внутри класса**, но **определяются** вне его. Это связано с тем, как компилятор и линкер работают с памятью.

### Почему это нужно:

1. **Объявление в классе:** Когда вы объявляете статическую переменную в классе, компилятор резервирует для нее пространство в памяти **только один раз**, вне зависимости от количества объектов этого класса. Объявление в классе лишь говорит компилятору, что такая переменная существует, но не создает ее.
    
2. **Определение вне класса:** Чтобы переменная была создана и заняла место в памяти, требуется ее **определение**. Это делается один раз в одном из `.cpp` файлов. Определение связывает переменную с реальным местом в памяти, и именно это позволяет переменной существовать как единственный экземпляр для всех объектов класса.
    

Если бы вы не сделали определения статической переменной в `.cpp`, то компилятор знал бы о ее существовании (через объявление в классе), но не мог бы связать ее с конкретным местом в памяти при компоновке.

### Что происходит на уровне компиляции и линковки:

- **На этапе компиляции**: Компилятор увидит, что у класса есть статическая переменная, и зарезервирует для нее место в таблице символов, но не выделит память.
- **На этапе линковки**: Когда линкер обнаружит определение переменной в `.cpp` файле, он выделит для нее память и свяжет ее с остальными частями программы.

Если вы не определите статическую переменную, то при попытке к ней обратиться , возникнет ошибка линковки **"undefined reference"**.

### Важное правило:

Каждая статическая переменная должна быть **определена** ровно один раз, иначе компоновщик не сможет понять, где она должна находиться в памяти.

### Пример:

#### В `ServiceModeSelector.hpp` (объявление):

```cpp
class ServiceModeSelector { 
public:     
static int prevWorkingMode;  // Объявление статической переменной };
```

#### В `ServiceModeSelector.cpp` (определение):

```cpp
int ServiceModeSelector::prevWorkingMode = 0;  // Определение статической переменной
```