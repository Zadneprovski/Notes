### Подача питания или аппаратный сброс

После подачи питания, **ядро Cortex-M (в STM32 — это Cortex-M0/M3/M4/M7 и т.д.) запускает так называемый Reset Sequence**. Он аппаратно зашит в само ядро ARM и **выполняется всегда одинаково**, независимо от производителя микроконтроллера.

STM32 микроконтроллеры имеют несколько источников тактирования, таких как внутренние и внешние осцилляторы. Сначала микроконтроллер использует внутренний осциллятор (HSI), чтобы начать работу. Затем, если в прошивке задано использовать внешний кварцевый резонатор, происходит переключение на него.

### Что делает ядро Cortex-M при сбросе?

1. **Считывает первый 32-битный указатель (по адресу 0x00000000)** — это начальное значение **Main Stack Pointer (MSP)**. 
	Это нужно, чтобы сразу начать использовать стек. Обычно это конец RAM.

2. **Считывает второй 32-битный указатель (по адресу 0x00000004)** — это адрес функции `Reset_Handler()` (то есть "точка входа").

3. Передаёт управление `Reset_Handler`.

Это стандарт Cortex-M, работает для всех STM32, NXP, Atmel и других ARM MCU.

### Запуск системы загрузки (Bootloader)

Перед `Reset_Handler()` STM32 проверяет BOOT пины и решает, откуда загружать код для выполнения :
- FLASH - память (адрес 0x0000 0000)
- встроенный загрузчик (раздел FLASH памяти - System)
- RAM

### Пример: что находится в начале памяти?

На STM32 начало flash (адрес `0x08000000`) **отображается на адрес 0x00000000 при запуске** — за счёт настройки **memory aliasing**.

В этом начале находится так называемый **вектор таблица прерываний (vector table)**:
```c
.section .isr_vector, "a", %progbits
const uint32_t *vector_table[] __attribute__((section(".isr_vector"))) = {
    (uint32_t*)&_estack,        // [0x00] Начальный MSP
    (uint32_t)Reset_Handler,    // [0x04] Адрес Reset_Handler
    ...
};
```

### Что делает `Reset_Handler()`

Это точка входа. Она:
1. Копирует `.data` из Flash в RAM
2. Обнуляет `.bss` (инициализация переменных нулями)
	[[Память STM32|Про .data и .bss]]
3. (Иногда) настраивает тактирование (если не через SystemInit)
4. Вызывает `SystemInit()` (из CMSIS) — базовая настройка системы
5. Вызывает функцию `main()` — и вот здесь начинается твой код

```c
void Reset_Handler(void) {
    __libc_init_array();   // Инициализация глобальных объектов (C++)
    SystemInit();          // Настройка тактирования и т.п.
    main();                // Запуск пользовательского кода
}
```

---

### Дополнительные детали

- **Вся таблица векторов (прерывания, Reset и т.д.)** располагается в `.isr_vector` — первой секции прошивки.
- Значение `_estack` указывается линкером, это верхняя граница RAM.
- При использовании STM32Cube, вся эта логика уже реализована внутри `startup_stm32xxxx.s` и `system_stm32xxxx.c`.

---
