`SysTick_Handler` — это обработчик прерывания от системного таймера **SysTick**, встроенного в ядро Cortex-M. Он предназначен для создания точных периодических событий, и чаще всего используется как **основа системного тика (system tick)** в операционных системах реального времени (RTOS), таких как FreeRTOS.

---

## Что такое SysTick?

`SysTick` — это 24-битный счётчик обратного отсчёта, встроенный в каждое ядро Cortex-M. Его особенности:

- Работает от системной частоты (обычно это HCLK).
- Может генерировать прерывание при достижении нуля.
- Может автоматически перезагружаться и продолжать отсчёт.
- Управляется через регистры: `CTRL`, `LOAD`, `VAL`.

SysTick — это часть **ядра** Cortex-M и не зависит от периферии конкретного микроконтроллера.

---

## Зачем нужен `SysTick_Handler`?

`SysTick_Handler` вызывается при каждом переполнении таймера SysTick. Это используется:

- В RTOS — для переключения задач по таймерам (системный тик).
- Для реализации `HAL_Delay()` и `millis()` в STM32Cube.
- Для создания стабильного времени в миллисекундах/микросекундах.

Пример частоты: если HCLK = 72 МГц и `SysTick->LOAD = 71999`, прерывание будет вызываться каждые 1 мс.

---

## Как используется в FreeRTOS

В FreeRTOS `SysTick_Handler`:

1. Увеличивает глобальный счётчик тиков (`xTickCount`).
2. Проверяет, не истекли ли таймауты задач/таймеров.
3. Если нужно — вызывает `PendSV` для переключения задач.

---

## Влияние на энергопотребление

Поскольку `SysTick_Handler` вызывается часто (например, каждые 1 мс), его код должен быть максимально коротким. Особенно это важно в энергозависимых приложениях, чтобы снизить нагрузку на ядро.

---

## Настройка SysTick

SysTick можно настроить вручную:
```c
SysTick->LOAD  = (SystemCoreClock / 1000) - 1; // 1 ms
SysTick->VAL   = 0;
SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
                 SysTick_CTRL_TICKINT_Msk   |
                 SysTick_CTRL_ENABLE_Msk;
```

Или через HAL:
```c
HAL_InitTick(TICK_INT_PRIORITY);
```
