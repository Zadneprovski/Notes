Аппаратное **предсказание ветвлений (branch prediction)** — это **механизм в CPU**, который **пытается угадать**, по какой ветке пойдёт выполнение кода при встрече с условным переходом (`if`, `for`, `while`, `switch`) **ещё до того, как будет вычислено условие**.

Это **важно**, потому что современные процессоры выполняют инструкции **параллельно и заранее** (pipelining, speculative execution), и любые "неожиданные" переходы ломают этот процесс.
## Почему это важно
Когда процессор встречает команду перехода (`branch`), он **не знает**, по какому пути пойдёт программа:
```c
if (x > 0)
    do_A();
else
    do_B();
```
Пока не вычислено `x > 0`, он **не знает**, исполнять `do_A` или `do_B`.  
А в **суперскалярных процессорах** (ARM Cortex-A, x86) каждая пауза — это **потеря тактов** и **падение производительности**.
## Как работает предсказание ветвлений
Микропроцессоры используют **аппаратные предсказатели ветвлений (branch predictors)**, чтобы **угадывать**, куда пойдёт выполнение.

Существует несколько **типов предсказателей**:
### 1. **Static Prediction** (статическое)

Самое простое, без истории:
- **Предсказание вперёд**: всегда считать, что переход **не произойдёт**
- Или: **всегда считать, что произойдёт**

Пример: условный переход назад (циклы) чаще считается «выполняющимся» (т.е. повторяется).
### 2. **Dynamic Prediction** (динамическое)
Использует **историю исполнения** предыдущих ветвлений:
#### **1-битовый предсказатель**
- Хранит 1 бит: "прошлый раз переход был выполнен — значит, и в этот раз тоже".
- Ошибка → бит меняется.
#### **2-битовый saturating counter (наиболее распространённый)**
- Состояния:  
    `00`: strongly not taken  
    `01`: weakly not taken  
    `10`: weakly taken  
    `11`: strongly taken

- **Изменение состояния** происходит только после 2 подряд ошибок → предсказатель становится **менее чувствительным к случайным колебаниям**.
### 3. **Branch Target Buffer (BTB)**
- Кэширует адреса инструкций `branch` и **куда они прыгнули**.
- При повторном исполнении — сразу предсказывает **адрес цели** перехода.
### 4. **Global History Table (GHT)** и **Pattern History Table (PHT)**
- Глобальная история переходов (например, 8 последних ветвлений)
- Используется как индекс для поиска шаблонов поведения
- Это даёт точные предсказания **даже для ветвлений, зависящих от контекста**
### 5. **Indirect Branch Prediction**

Для `switch-case`, `virtual functions`, `function pointers`:
- Цель перехода заранее неизвестна
- CPU обучается ассоциировать адрес инструкции с вероятным адресом цели
## Что происходит при ошибке?

Если процессор **неправильно предсказал** ветку:
1. Он **отменяет инструкции**, которые уже начал выполнять по неверной ветке.
2. Загружает правильный путь и **заново начинает выполнение**.

Это называется **pipeline flush** и может стоить **десятки тактов**!
## Что в STM32 и Cortex-M?

- Cortex-M (M0, M3, M4, M7) **не имеет сложных предсказателей**, но:
    - Cortex-M3/M4: **предсказывают условные переходы назад как taken (выполняются)**.
    - Cortex-M7: уже имеет **примитивный динамический предсказатель**.
- Нет BTB или сложных таблиц.

А вот **Cortex-A (например, в Raspberry Pi, смартфонах)** — полноценные предсказатели с BTB, GHT и PHT.
## Эффективность
Хороший предсказатель на x86 или ARM Cortex-A может давать **точность 95–99%**!
## Итого

|Тип предсказания|Особенности|
|---|---|
|Статическое|Всегда `taken` или `not taken`|
|1-бит|Просто, быстро, ошибается при колебаниях|
|2-бит|Более устойчив, точнее|
|BTB|Предсказывает адрес цели|
|GHT + PHT|Обнаруживает шаблоны поведения|
|Indirect prediction|Для `switch`, vtables|