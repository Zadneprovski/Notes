ПИД-регулятор— это устройство, используемое в системах автоматического управления для поддержания заданного значения величины. 

### ПИД-регулятор состоит из трех компонентов:

1. **Пропорциональный (P)**: отвечает за текущее значение ошибки. Чем больше ошибка, тем больше управляющее воздействие. Это позволяет быстро реагировать на изменения, но может приводить к устойчивым отклонениям.

2. **Интегральный (I)**: Этот компонент учитывает накопленную ошибку за все время работы регулятора. Он помогает устранить устойчивые отклонения, так как со временем накапливает влияние ошибки.

3. **Дифференциальный (D)**: Этот компонент предсказывает будущее поведение ошибки, основываясь на её текущем изменении. Он позволяет сгладить реакции системы и уменьшить колебания.

Вычисление выходного значения ПИД-регулятора осуществляется по следующей формуле:
$$u(t)=Kp⋅e(t)+Ki\cdot \int_0^te(τ) dτ+Kd⋅\frac{de(t)}{dt}$$
где:

- $u(t$) — выходное значение регулятора (управляющее воздействие).
- $e(t)$ — ошибка в момент времени t (разница между заданным и текущим значением).
- $Kp$ — коэффициент пропорциональности.
- $Ki$ — коэффициент интеграции.
- $Kd$— коэффициент дифференцирования.
- $\int_0^t e(\tau) \, d\tau$ — интеграл ошибки за время от 0 до t.
- $\frac{de(t)}{dt}$​ — производная ошибки по времени.
### Шаги для вычисления:

1. **Определить ошибку**:
$$e(t)=заданное\ значение−текущее\ значение$$
2. **Рассчитать интеграл ошибки**: Для простоты можно использовать численное интегрирование. Например, если вычисляете значение на каждом шаге времени:
$$\int_0^t e(\tau) \, d\tau \approx \sum_{i=0}^{n} e(i) \cdot \Delta t$$
	где $\Delta t$— шаг по времени.

3. **Рассчитать производную ошибки**: Можно использовать обратный разностный метод:
$$\frac{de(t)}{dt} \approx \frac{e(t) - e(t - \Delta t)}{\Delta t}​$$
4. **Подставьте значения в формулу**: После вычисления ошибки, интеграла и производной, подставьте их в формулу ПИД-регулятора.
#### Пример:

```python
# Параметры ПИД
kp = 2.0
ki = 1.0
kd = 0.5

# Начальные значения
integral = 0
prev_error = 0
dt = 0.1

# Входы
setpoint = 100
measurement = 80

# ПИД-расчёт
error = setpoint - measurement
integral += error * dt
derivative = (error - prev_error) / dt
output = kp * error + ki * integral + kd * derivative
prev_error = error
```

### Частота обновления
Частота обновления ПИД может быть разной, для этого и учитывается dt при расчетах, в противном случае можно было считать без dt, все работало бы.
Частота обновления ПИД не должна быть выше, чем измерение сигнала

Частота регулирующего ШИМ сигнала:
- **Для моторов:** 10–20 кГц, чтобы не было слышимого писка.
- **Для светодиодов/нагревателей:** можно 500–1000 Гц (они медленные).

### Anti-windup
Это защита PID-регулятора от накопления "лишней" интегральной ошибки, когда выход **упирается в пределы**, и **система не может ответить**.

Существует два метода:
- Back calculation - если выход обрезан, пересчитать, **насколько "лишнего" дал PID**, и отнять это от интеграла.
- Clamping - ограничение интеграла (обычно 50-80% от максимального выходного сигнала), то есть, когда накопленная ошибка достигает определенного значения, она перестает расти
### Использование посчитанного значения
Предполагается, что посчитанное значение с регулятора необходимо напрямую устанавливать в управляющий сигнал, но когда управление осуществляется мотором с помощью ШИМ сигнала, то посчитанное значение нужно прибавить к предыдущему управляющему сигналу, потому что ПИД регулятор выдает отрицательные значения, в случае превышения уставки. 

## Дискретный ПИД
Дискретная формула ПИД-регулятора (инкрементальная форма — удобна в реализации):
$$u[k]=u[k−1]+Kp​⋅(e[k]−e[k−1])+Ki​⋅T⋅e[k]+\frac{Kd​​}{T}⋅(e[k]−2e[k−1]+e[k−2])$$
где,
- $u[k]$ — новое управляющее воздействие.
- $u[k−1]$ — предыдущее управляющее воздействие.
- $e[k]$, $e[k−1]$, $e[k−2]$ — текущая, предыдущая и предпредыдущая ошибки.
- $K_p$ — пропорциональный коэффициент.
- **$K_i​$** — интегральный коэффициент.
- $K_d$​ — дифференциальный коэффициент.
- $T$ — постоянный шаг дискретизации.

### Преимущества инкрементальной формы:

- Не требует постоянного хранения суммы ошибок (интеграла).
- Более устойчива к насыщению выхода (например, если у тебя ограничено PWM).
- Удобна для реализации с ограничением на максимальные/минимальные значения $u[k]$.
- Разность $e[k]−e[k−1]$ — это изменение ошибки → пропорциональная составляющая изменения.
- $Ki​⋅T⋅e[k]$ — "приращение" интеграла.
- $e[k]−2e[k−1]+e[k−2]$ — приближение второй производной (ускорение ошибки) → дифференциальная часть.