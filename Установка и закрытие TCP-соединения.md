
При каждом HTTP-запросе по протоколу TCP сначала **устанавливается соединение** между клиентом (твоим компьютером) и сервером (например, `api.github.com`).

## **Трёхступенчатое рукопожатие (TCP 3-way handshake)**

Чтобы соединиться, клиент и сервер должны **три раза обменяться данными**:

1. **Клиент → Сервер: SYN (synchronize)**
    
    - Клиент отправляет запрос на открытие соединения (SYN-пакет).
    - В этом пакете содержится начальный **номер последовательности (sequence number)**.
2. **Сервер → Клиент: SYN-ACK (synchronize-acknowledge)**
    
    - Сервер получает запрос, соглашается установить соединение.
    - Отправляет обратно подтверждение (SYN-ACK) с **своим номером последовательности**.
3. **Клиент → Сервер: ACK (acknowledge)**
    
    - Клиент подтверждает (ACK) получение SYN-ACK.
    - Теперь соединение установлено, можно передавать данные!

 Этот процесс занимает **несколько миллисекунд**, но если соединение устанавливается часто (например, при множественных HTTP-запросах без `ClientSession`), это создаёт **лишнюю нагрузку на сеть и сервер**.

---

##  Почему установка соединения затратная?

Каждое новое TCP-соединение требует: **Сетевого трафика** — обмен тремя пакетами (SYN, SYN-ACK, ACK).  
 **Времени** — задержка из-за сетевой латентности (особенно на больших расстояниях).  
 **Ресурсов сервера** — он должен обрабатывать каждый новый запрос и хранить информацию о соединении.

Если соединение закрывается после каждого запроса (без `ClientSession`), то **каждый новый запрос требует нового рукопожатия**, что замедляет работу.

---

##  А если используется HTTPS?

При HTTPS (защищённое соединение) к TCP добавляется ещё один этап — **TLS-рукопожатие**:

1. Клиент и сервер договариваются об алгоритмах шифрования.
2. Клиент и сервер обмениваются криптографическими ключами.
3. Устанавливается **безопасный канал** передачи данных.

 **TLS-рукопожатие ещё более затратное**, так как требует **нескольких дополнительных обменов** данными. Поэтому **если делать много HTTPS-запросов без `ClientSession`**, это будет **ещё медленнее**.
## Как `ClientSession` помогает?

Когда ты используешь `ClientSession`, **соединение открывается один раз и переиспользуется** для всех запросов. Это значит:  
- **Один TCP-handshake вместо множества**.  
- **Одно TLS-рукопожатие (если HTTPS)**.  
- **Меньше задержек, быстрее работа**.

Пример без `ClientSession` (каждый запрос → новое соединение):
```
[SYN] → [SYN-ACK] → [ACK] → [GET-запрос] → [Закрытие соединения]
[SYN] → [SYN-ACK] → [ACK] → [GET-запрос] → [Закрытие соединения]
[SYN] → [SYN-ACK] → [ACK] → [GET-запрос] → [Закрытие соединения]
```

Пример с `ClientSession` (одно соединение, несколько запросов):
```
[SYN] → [SYN-ACK] → [ACK] → [GET-запрос] → [GET-запрос] → [GET-запрос] → [Закрытие соединения]
```

## Как сервер узнаёт, что соединение закрыто?

Когда клиент (твой код) **заканчивает работу** с сервером, он должен сообщить об этом. В TCP для этого есть **четырёхшаговое закрытие соединения (4-way handshake)**:

1. **Клиент → Сервер: FIN (finish)**
    
    - Клиент отправляет `FIN` (finish) пакет → "Я закончил передачу данных".
2. **Сервер → Клиент: ACK (acknowledge)**
    
    - Сервер подтверждает `ACK` → "Я понял, что ты закончил".
3. **Сервер → Клиент: FIN**
    
    - Когда сервер тоже закончит передачу, он отправляет `FIN` → "Я тоже закончил".
4. **Клиент → Сервер: ACK**
    
    - Клиент подтверждает `ACK`, соединение закрывается.

 Если соединение закрыто, **сервер освобождает ресурсы и забывает о клиенте**.

---

## Как сервер понимает, что клиент **использует сессию**?

Когда используется `aiohttp.ClientSession()`, запросы идут через **одно и то же TCP-соединение**. Сервер это понимает **благодаря заголовку** `Connection: keep-alive`.

 **Пример заголовков запроса без сессии (новое соединение каждый раз)**:
```
 GET / HTTP/1.1
Host: api.github.com
Connection: close  <-- Сервер понимает, что соединение закрывается
```
После обработки запроса сервер **автоматически закрывает соединение**.

**Пример заголовков запроса при использовании `ClientSession` (соединение сохраняется)**:
```
GET / HTTP/1.1
Host: api.github.com
Connection: keep-alive  <-- Сервер понимает, что клиент хочет держать соединение открытым
```
**Сервер оставляет соединение открытым и ждёт новые запросы от клиента**.

---

## Когда сервер всё-таки закрывает соединение?

Даже если клиент использует `keep-alive`, сервер **не будет держать соединение бесконечно**. Он может закрыть его в трёх случаях:

1. **Тайм-аут (timeout)**
    
    - Если клиент **слишком долго не отправляет запросы**, сервер разрывает соединение.
2. **Лимит запросов**
    
    - Некоторые серверы закрывают соединение, если через него прошло **слишком много запросов**.
3. **Ручное закрытие клиентом**
    
    - Если клиент **сам вызовет `session.close()`**, он отправит `FIN`, и сервер закроет соединение.