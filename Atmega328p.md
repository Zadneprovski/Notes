[[Библиотека AVR-libc]]
[[Разделение памяти на код и данные у AVR]]

Используя **Arduino IDE**,  производительность кода будет точно такой же, как при использовании других способов программирования, например, через `avr-gcc` в терминале. Arduino IDE сама по себе — это просто удобная оболочка для работы с кодом и прошивкой. Если вы используете **регистры напрямую**, то ваш код не будет оборачиваться в дополнительные вызовы или библиотечные функции.

Arduino IDE просто компилирует и загружает код через стандартный загрузчик (bootloader) [[Bootloader Arduino Optiboot]]. 

При прошивке через загрузчик, необходимо подать сигнал

Написав стандартный `main()`, не используя setup() и loop() из <Arduino.h> ничего лишнего вызываться не будет

## Инициализация микроконтроллера 
### 1. **Начальный запуск (Reset)**

После включения питания или сброса, ATmega328P выполняет аппаратные действия, чтобы подготовиться к выполнению программы:

1. **Включение источника тактового сигнала**:
    
    - Микроконтроллер выбирает источник тактового сигнала (по умолчанию это встроенный кварц на 16 МГц для Arduino Uno).
    - Если используется внешний кварц или внутренний RC-генератор, переключение зависит от фьюз-битов.
2. **Стабилизация тактового сигнала**:
    
    - При использовании кварцевого генератора микроконтроллер ожидает стабилизации частоты, это занимает около 16 мс.
3. **Аппаратный сброс регистров**:
    
    - Все регистры устанавливаются в начальные значения:
        - Все пины настроены как входы.
        - Таймеры, UART, SPI, и другие периферийные модули отключены.
        - Переменные памяти (SRAM) остаются неинициализированными.

---

### 2. **Запуск загрузчика (если он есть)**

Если фьюз-бит `BOOTRST` настроен на запуск загрузчика, выполнение начинается с области памяти **Boot section**, где находится загрузчик, например **Optiboot**.

1. Загрузчик проверяет, поступают ли данные на UART для новой прошивки.
2. Если данных нет, загрузчик передает управление основной программе в **Application section** (адрес 0x0000).

> Если загрузчик не активирован, выполнение сразу начинается с основной программы.

---

### 3. **Запуск пользовательской программы**

После прохождения загрузчика (или при его отсутствии) микроконтроллер начинает выполнение программы, записанной в памяти **Application section**. Вот что происходит дальше:

#### **Стартовый код C (CRT)**

При компиляции проекта на C/C++ компилятор `avr-gcc` автоматически добавляет стартовый код, который выполняет базовую инициализацию:

1. **Инициализация стека**:
    
    - Регистр указателя стека (**SP**) устанавливается на конец SRAM (например, для ATmega328P это 0x08FF).
2. **Обнуление неинициализированных данных**:
    
    - Секция `.bss` (глобальные переменные без начальных значений) заполняется нулями.
3. **Копирование инициализированных данных**:
    
    - Секция `.data` (глобальные переменные с начальными значениями) копируется из флэш-памяти в SRAM.
4. **Вызов функции `main()`**:
    
    - После выполнения всех подготовительных операций вызывается ваша функция `main()`.
### 4. **Инициализация Arduino (если используется)**

Если вы используете Arduino IDE, перед вызовом вашей функции `setup()` автоматически вызывается библиотечная функция `init()`, которая делает следующее:

1. **Настройка таймера `Timer0`**:
    
    - Таймер 0 конфигурируется для работы с миллисекундным разрешением. Это нужно для функций `millis()` и `delay()`.
2. **Инициализация UART**:
    
    - Настраивается UART для работы на 9600 бод по умолчанию (если вы используете `Serial.begin()`, параметры UART перенастраиваются).
3. **Инициализация прерываний**:
    
    - Глобальные прерывания разрешены (`sei()`).

После этого вызываются ваши функции `setup()` и `loop()`.

---

### Что нужно инициализировать вручную?

Если вы не используете Arduino, но работаете напрямую с регистрами AVR, вы должны выполнить начальную настройку самостоятельно, аналогично STM32, хотя объем работы меньше. Пример:

1. Тактовый сигнал
   - Обычно ничего не требуется, так как он уже настроен аппаратно.
2. Настройка GPIO
3.  Таймеры
4. Прерывания
5. Периферия (UART, SPI, I2C)
