**Name Mangling** (искажение имён) — это механизм в Python, который автоматически изменяет имя атрибута, чтобы предотвратить случайное или намеренное переопределение или конфликт имён при наследовании. Name Mangling применяется только к атрибутам, имя которых начинается с двух нижних подчёркиваний (`__`), но не заканчивается двумя подчёркиваниями.
### Как работает Name Mangling?

1. Если вы создаёте атрибут с именем, начинающимся с двух подчёркиваний (`__`), Python автоматически изменяет его имя, добавляя перед ним имя класса.
2. Такое преобразование помогает избежать случайного конфликта имён между атрибутами в классах, особенно в иерархиях наследования.

#### Пример:

```python
class MyClass:
    def __init__(self):
        self.__private_attr = 42

    def get_private_attr(self):
        return self.__private_attr

obj = MyClass()

# Попытка доступа к __private_attr напрямую:
# print(obj.__private_attr)  # Ошибка: AttributeError

# Но это имя автоматически преобразовано:
print(obj._MyClass__private_attr)  # 42
```
---

### Алгоритм Name Mangling:

1. Если имя атрибута начинается с `__` и не заканчивается `__`, Python преобразует его в:
```python
_<ИмяКласса>__<ИмяАтрибута>
```
1. где `<ИмяКласса>` — это имя текущего класса, в котором определён атрибут.
    
2. Если класс унаследован, Name Mangling учитывает имя текущего класса, а не родительского.
    

---

### Почему используется Name Mangling?

1. **Изоляция атрибутов:** Name Mangling помогает скрыть "приватные" атрибуты класса, чтобы они не были случайно переопределены или использованы в подклассах.
    
2. **Защита от конфликтов в наследовании:** Если подкласс определяет атрибут с таким же именем, Name Mangling позволяет сохранить оба атрибута в изолированном пространстве.
    

#### Пример защиты:
```python
class Parent:
    def __init__(self):
        self.__hidden = "Parent hidden"

class Child(Parent):
    def __init__(self):
        super().__init__()
        self.__hidden = "Child hidden"

obj = Child()

# Доступ к "приватным" атрибутам:
print(obj._Parent__hidden)  # Parent hidden
print(obj._Child__hidden)   # Child hidden
```
### Ограничения Name Mangling

1. **Name Mangling не делает атрибут полностью "приватным":** Атрибуты всё равно можно достать, зная правила преобразования имён.
    
2. **Name Mangling не применяется к атрибутам, начинающимся или заканчивающимся одним подчёркиванием:**
    
    - `_protected`: просто соглашение, обозначающее, что атрибут предназначен для внутреннего использования.
    - `__special__`: исключение из Name Mangling, используется для магических методов (`__init__`, `__new__`, `__str__`, и т.д.).

#### Пример исключений:
```python
class Example:
    def __init__(self):
        self._protected = "Protected"
        self.__private = "Private"
        self.__special__ = "Special"

obj = Example()

print(obj._protected)       # Protected (обычный атрибут)
print(obj._Example__private)  # Private (name mangling)
print(obj.__special__)      # Special (name mangling не применяется)
```
3. **Name Mangling работает только внутри класса:** Оно не защищает атрибуты от умышленного доступа извне. Python следует философии "мы все взрослые люди" (We're all consenting adults here).

---

### Когда использовать Name Mangling?

- Если вы пишете библиотеку или модуль, где нужно защитить атрибуты от случайного переопределения в подклассах.
- Для создания "по-настоящему приватных" атрибутов (насколько это возможно в Python).
- Для сложных иерархий классов, где могут быть конфликты имен.

---

### Когда **не** стоит использовать Name Mangling?

- Если вам просто нужно обозначить "непубличный" атрибут, достаточно использовать `_single_underscore` (это соглашение PEP 8).
- Если вы не ожидаете, что класс будет часто наследоваться.

---

### Итог:

**Name Mangling**:

- Это механизм автоматической трансформации имён атрибутов с префиксом `__`.
- Используется для предотвращения конфликтов имён в сложных иерархиях классов.
- Помогает "скрыть" атрибуты, но не делает их полностью приватными.

Если вам нужно просто обозначить атрибут для внутреннего использования, следуйте стандарту PEP 8 и используйте `_single_underscore`.