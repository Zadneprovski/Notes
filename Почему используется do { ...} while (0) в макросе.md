### Пример:

```c
#define ATOMIC_SET_BIT(REG, BIT)                             \
  do {                                                       \
    uint32_t val;                                            \
    do {                                                     \
      val = __LDREXW((__IO uint32_t *)&(REG)) | (BIT);       \
    } while ((__STREXW(val,(__IO uint32_t *)&(REG))) != 0U); \
  } while(0)
```
---

### Наружный `do { ... } while(0)` — **классический приём обёртки макросов**

Это нужно для **безопасного использования макроса в любом контексте**, например:
```c
if (x > 0)
    ATOMIC_SET_BIT(GPIOA->ODR, (1 << 5));
else
    do_something();
```
Без `do { ... } while(0)` макрос развернётся как:
```c
if (x > 0)
    uint32_t val; do { ... } while (...);
else
    do_something();
```
Ошибка компиляции (или ещё хуже — логическая ошибка), потому что `if` ожидает **одно выражение**, а макрос — блок без фигурных скобок.

---

### Решение: `do { ... } while (0)` превращает макрос в **единичное выражение**.

```c
if (cond)
    ATOMIC_SET_BIT(...); // безопасно
```
Таким образом, он всегда работает **как одна инструкция**, независимо от окружения: