Это протокол, позволяющий двум и более сторонам получить общий секретный ключ, используя незащищенный от прослушивания канал связи. Полученный ключ используется для шифрования дальнейшего обмена с помощью алгоритмов [[Симметричное шифрование|симметричного шифрования]].
Схема открытого распределения ключей, предложенная Диффи и Хеллманом, произвела настоящую революцию в мире шифрования, так как снимала основную проблему классической криптографии — проблему распределения ключей.

В чистом виде алгоритм Диффи — Хеллмана уязвим для модификации данных в канале связи, в том числе для атаки «Man-in-the-middle (человек посередине)», поэтому схемы с его использованием применяют дополнительные методы односторонней или двусторонней аутентификации.

### Алгоритм получения общего ключа

- **p** - большое простое число, рекомендуется минимум 1024 бит (308 знаков)
- Общим ключом в данном случае является **16**;
- Числа **5** и **8** выбраны случайно и должны держаться в секрете;
- Числа **29** и **3** являются открытыми и доступными обоим.

![[Pasted image 20240922225058.png]]

Алгоритм Диффи-Хеллмана (DH) обеспечивает **прямую секретность (forward secrecy)** благодаря тому, что при каждом новом сеансе обмена данными создаётся **уникальный сеансовый ключ**, который не зависит от длительных (постоянных) ключей, используемых сторонами.

Чтобы понять, как это работает и почему это важно, рассмотрим несколько ключевых моментов:

### 1. Временные (сеансовые) ключи

Каждый раз, когда две стороны используют алгоритм Диффи-Хеллмана для установления ключа шифрования, они генерируют **новые временные (сеансовые)** ключи, которые используются только для текущего сеанса. Эти временные ключи **никогда не передаются напрямую** по сети. Вместо этого стороны обмениваются публичными частями своих ключей и вычисляют общий секрет на основе своих приватных ключей и полученной информации.

### 2. Прямая секретность

Прямая секретность означает, что даже если злоумышленник каким-то образом получит доступ к долговременным приватным ключам одной или обеих сторон (например, из-за компрометации сервера), он **не сможет расшифровать прошедшие сессии**. Это происходит потому, что долговременные ключи не используются для генерации сеансовых ключей напрямую. Каждый сеанс генерирует новый ключ на основе временных параметров, что делает невозможным расшифровку старых данных.