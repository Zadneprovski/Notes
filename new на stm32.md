Вызов `new` на **STM32 без операционной системы (bare-metal)** — это **не системный вызов в привычном смысле (как в Linux)**. Он **не вызывает ядро ОС**, потому что... ОС нет. Вместо этого `new` — это **обычная функция**, реализованная в вашей C++ runtime-библиотеке, и она **в конечном итоге вызывает `malloc()`**.

---

## Что делает `new` на STM32

### Пример:

```cpp
MyClass* obj = new MyClass();
```
Что реально происходит:

1. `new` вызывает **`operator new(size_t)`**.
2. `operator new` вызывает **`malloc(size)`** для выделения памяти.
3. Если память выделена успешно, вызывается **конструктор `MyClass()`** по адресу.
4. Возвращается указатель на объект.

---

## Но кто реализует `malloc()`?

В embedded-средах (STM32 + GCC), `malloc()` — это часть **новойlib (newlib)** или другой стандартной библиотеки. Она использует специальную функцию `sbrk()`:

### Поток вызова:

```cpp
new → operator new → malloc → _sbrk → ваша реализация
```
---

## Что такое `_sbrk`?

`sbrk` — это функция, которая **управляет кучей (heap)**: перемещает "указатель на конец кучи" вперёд, чтобы выделить память. **Вы обязаны реализовать её вручную**, если используете `malloc` или `new` на bare-metal.

### Пример реализации `_sbrk`:

```cpp
extern "C" {
  extern char _end; // символ от линкера — конец .bss
  static char* heap_end = &_end;

  void* _sbrk(ptrdiff_t incr) {
    char* prev_heap_end = heap_end;
    heap_end += incr;
    return (void*) prev_heap_end;
  }
}
```
Эта реализация **не проверяет границы памяти!** В реальных проектах ты должен проверять, чтобы `heap_end` не пересёкся со стеком.

---

## Что будет, если вызвать `new`, а `_sbrk` не реализован?

Будет **link-time ошибка** (undefined reference to `_sbrk`) или **runtime краш**, если newlib собрана с dummy-версией `_sbrk`.

---

## А если `new` нельзя использовать?

Ты можешь:

- Использовать **размещение в статической памяти**, без динамики.
- Заменить `new/delete` на **специализированный аллокатор**.
- Запретить `new/delete` через перегрузку:


```cpp
void* operator new(size_t) { while (1); }
void operator delete(void*) noexcept { while (1); }
```

---

## Вывод

 На STM32 без ОС, `new` — это просто синтаксический сахар, который вызывает `malloc()` и конструктор.

Но `malloc()` в свою очередь зависит от функции `_sbrk()`, которую **должен реализовать программист**.

Если этого не сделать — `new` не будет работать. Это не "системный вызов", как в Linux — это часть **C/C++ runtime**, которую ты **должен построить сам**.