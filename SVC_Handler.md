`SVC_Handler` — это обработчик **Supervisor Call (SVC)** — одного из системных прерываний в ядрах Cortex-M.

Он **вызывается, когда в коде выполняется инструкция `SVC`**, которая позволяет безопасно переключиться из **режима пользователя в привилегированный режим** для выполнения **системных функций**.

---

## Что делает инструкция `SVC`?

Инструкция `SVC` (`Supervisor Call`) используется в коде как:
```
SVC #номер
```
или в C:
```c
__asm("SVC #0");
```

При её выполнении происходит:

1. **Исключение (прерывание)** → Cortex-M вызывает `SVC_Handler`.
2. Контекст сохраняется на стек (как при любом исключении).
3. Процессор переходит в **Handler Mode**, с повышенными правами доступа (если используется разделение привилегий).

Таким образом, это способ вызвать **привилегированную функцию** из **непривилегированного кода**.

---

## Где используется `SVC_Handler`?

### 1. **Операционные системы (например, FreeRTOS)**

В FreeRTOS `SVC_Handler` используется для:

- **Запуска первой задачи** (`vPortStartFirstTask`).
- Позволяет переключиться от "голого" старта на управление контекстом ОС.

На старте OS вызывает `SVC 0`, и `SVC_Handler` восстанавливает контекст первой задачи и начинает её выполнение.

---

### 2. **Разделение привилегий (MPU)**

В Cortex-M можно запускать код в **непривилегированном режиме** (например, сторонний модуль или безопасный плагин). Такой код:

- не может напрямую обращаться к периферии,
- не может менять системные регистры.

Для выполнения безопасной системной функции такой код вызывает `SVC` → управление переходит в `SVC_Handler`, где уже выполняется проверенный привилегированный код.

---

### 3. **Системные вызовы (аналог `syscall` в Linux)**

Можно реализовать **свою таблицу системных вызовов**, где каждый `SVC #номер` вызывает нужную функцию:

```c
void SVC_Handler(void) {
    uint32_t svc_number;

    // Получение номера SVC
    __asm volatile (
        "TST lr, #4 \n"
        "ITE EQ \n"
        "MRSEQ r0, MSP \n"
        "MRSNE r0, PSP \n"
        "LDR r1, [r0, #24] \n"       // r1 = PC at time of SVC
        "LDRB r2, [r1, #-2] \n"      // r2 = SVC number
        "MOV %0, r2 \n"
        : "=r" (svc_number)
        :
        : "r0", "r1", "r2"
    );

    switch (svc_number) {
        case 0:
            // Запуск задачи
            break;
        case 1:
            // Вывод строки
            break;
        default:
            // Неизвестный вызов
            break;
    }
}
```


## Особенности реализации

- `SVC_Handler` должен быть **коротким и быстрым**, потому что он работает в режиме исключения.
- Работает **в привилегированном режиме**.
- На вход ему не передаются аргументы напрямую — их надо извлекать из регистра или стека вручную.

---

## Безопасность и контроль

SVC — это единственный способ для **непривилегированного кода вызвать привилегированные действия** (при включённом MPU). Поэтому:

- Системный API должен быть тщательно спроектирован.
- В `SVC_Handler` должна быть валидация и проверка параметров.
- Нельзя давать прямой доступ к чувствительным ресурсам.

---

## В связке с RTOS

В FreeRTOS `SVC_Handler`:

- Не используется часто после запуска (в отличие от `PendSV_Handler`).
- Применяется только **один раз** — чтобы запустить планировщик.

---

## Вывод

`SVC_Handler` — это мощный механизм системных вызовов в ARM Cortex-M. Он:

- Позволяет делать "безопасные входы" в системный код,
- Применяется в ОС, безопасности, пользовательских API,
- Реализует аналог `syscall` из больших ОС.

Если ты используешь RTOS — он уже используется «под капотом». Но если пишешь свою "мини-ОС" или хочешь внедрить безопасность через MPU — `SVC` станет твоим инструментом.