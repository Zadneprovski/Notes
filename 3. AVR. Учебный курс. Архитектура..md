Основой любого микроконтроллера является вычислительное ядро. Во всех моделях AVR оно практически одинаковое и это большой плюс. Именно единство архитектуры обеспечивает легкую переносимость кода.

Итак, что же у нас в основе микроконтроллера, взгляни на диаграмму:
![[Pasted image 20241215160302.png]]
Ядро состоит, в первую очередь, из памяти программ (Flash Programm Memory) и Арифметико-логического устройства (ALU), блока управления (на диаграмме не показан) и программного счетчик (Program Counter). Также есть тактовый генератор, задающий импульсы относительно которых работают блоки микроконтроллера. Тактовый генератор можно сравнить с маятником и собачкой в будильнике: маятник туда сюда, собачка тикает по одному зубчику — шестеренки крутятся. Встала собачка — встал весь будильник.

При старте микроконтроллера значение программного счетчика равно 0000 — это адрес первой команды в нашей flash ROM. Микроконтроллер хватает оттуда два байта (код команды и ее аргументы) и отдает на выполнение в декодер команд (Instruction Decoder).

А дальнейшая судьба зависит от команды. Если это просто команда работы с какими-либо действиями, то они будут выполнены, а на следующем такте значение программного счетчика будет увеличено и из следующей пары ячеек памяти будут взяты еще два байта команды и также отправлены на выполнение.  
  
Все интересней становится когда встречается команда перехода. В этом случае в Программный счетчик загружается адрес указанный в команде (абсолютный переход) или его значение увеличивается не на 1, а на столько сколько нужно и на следующем такте микроконтроллер возьмет команду уже с нового адреса.

Декодер команд загребает команду и скармливает ее логике блока управления, который уже пинает все остальные блоки, заставляя их делать нужные действия в нужном порядке.

Вся математика и обработка делается посредством ALU. Это, своего рода, калькулятор. Он может складывать, вычитать, сравнивать, сдвигать разными способами, иногда делить и умножать (это считается круто, встречается редко).

В качестве промежуточных операндов используются 32 ячейки — Оперативные регистры общего назначения РОН. Доступ к этим ячейкам самый быстрый, а число операций с их содержимым наиболее богатое. В ассемблере регистры эти называются просто R0,R1,R2 … R31. Причем делятся они на три группы:

**Младшие R0..R15**  
Обычные регистры общего назначения, но какие то ущербные. С ними не работают многие команды, например, такие как загрузка непосредственного числа. Т.е. нельзя, например, взять и присвоить регистру число. Зато можно скопировать число из любого другого регистра.

**Старшие R16..R31**  
Полноценные регистры, работающие со всеми командами без исключения.

**Индексные R26…R31**  
Шесть последних регистров из старшей группы особенные. В принципе, их можно юзать и как обычные регистры общего назначения. Но, кроме этого, они могут образовывать регистровые пары X(R26:R27), Y(R28,R29), Z(R30:R31) которые используются как указатели при работе с памятью.

**ОЗУ**  
Кроме 32 регистров в микроконтроллере есть оперативная память. Правда не везде — в младших семействах AVR Tiny12 и Tiny11 оперативной памяти нет, так что приходиться вертеться в 32 ячейках.

Оперативная память это несколько сотен ячеек памяти. От 64 байт до 4килобайт, в зависимости от модели. В этих ячейках могут храниться любые данные, а доступ к ним осуществляется через команды Load и Store.

То есть нельзя взять, например, и прибавить к ячейке в памяти, скажем, единицу. Нам сначала сделать операцию Load из ОЗУ в РОН, потом в регистре прибавить нашу единицу и операцией Store сохранить ее обратно в память. Только так.

**EEPROM**  
Долговременная память. Память которая не пропадает после выключения питания. Если Flash может содержать только код и константы, а писать в нее при выполнении ничего нельзя (Это память Read Only), то в ЕЕПРОМ можно сколько угодно писать и читать. Но в качестве оперативки ее особо не поюзаешь. Дело в том, что цикл записи в EEPROM длится очень долго — миллисекунды. Чтение тоже не ахти какое быстрое. Да и число циклов перезаписи всего 100 000, что не очень много в масштабах работы оперативной памяти. ЕЕПРОМ используется для сохранения всяких настроек, предустановок, собранных данных и прочего барахла, что может потребоваться после включения питания и в основном на чтение. Эта память есть не во всех моделях AVR, но в подавляющем их большинстве.

**Периферия**  
Периферия это внутренний фарш микроконтроллера. То что делает его таким универсальным. ALU, RAM, FLASH и Блок управления это как в компе Мать, Проц, Память, Винт — то без чего комп даже не запустится толком. То периферия это уже как сетевуха, видяха, звуковая карта и прочие прибамбасы. Они могут быть разными, разной степени крутости и навороченности, а также комбинироваться в разном порядке.

Именно по наличию на кристалле той или иной периферии происходит выбор микроконтроллера под задачу.

Периферии всякой придумано великое множество, всего я наверное даже не опишу. Но дам основной набор присутствующий почти во всех AVR, а также в других современных контроллерах.

- Порты ввода вывода — то без чего невозможно взаимодействие контроллера с внешним миром. Именно порты обеспечивают то самое «ножкодрыгательство» управляющее другими элементами схемы. Захотели получить на выводе единичку, дали приказ соответствующему порту — получите, распишитесь. Захотели узнать какой там сигнал на входе? Спросили у соответствующего порта — получили. Почти все выводы микроконтроллера могут работать в режиме портов ввода-вывода.
- UART/USART приемопередатчик — последовательный порт. Работает по тому же асинхронному протоколу что и древние диалапные модемы. Старый как мир, надежный и простой как кувалда. Подходит для связи с компьютером и другими контроллерами.
- Таймеры/счетчики — задача таймеров отсчитывать тики. Сказал ему отсчитать 100 тактов процессора — он приступит и как досчитает подаст сигнал. Им же можно подсчитывать длительность входных сигналов, подсчитывать число входных импульсов. Да много чего умеет таймер, особенно в AVR. Подробное описание функций таймера занимает добрых три десятка страниц в даташите. При том, что таймеров самих существует несколько видов и фарш у них разный.
- АЦП — аналоговый вход. Есть не у всех микроконтроллеров, но вещь полезная. Позволяет взять и замерить аналоговый сигнал. АЦП это своеобразный вольтметр.
- I2C(TWI) интерфейс — последовательная шина IIC. Через нее осуществляется связь с другими устройствами. На IIC можно организовать своеобразную локальную сеть из микроконтроллеров в пределах одного устройства.
- SPI — еще один последовательный протокол, похожа на IIC, но не позволяет организовывать сети. Работает только в режиме Мастер-Ведомый. Зато ОЧЕНЬ быстрая.
- Аналоговый Компаратор — еще один аналоговый интерфейс. Но, в отличии от АЦП, он не замеряет, а сравнивает два аналоговых сигнала, выдавая результат А>B или A<B в двоичном виде.
- JTAG/DebugWire — средство отладки, позволяет заглянуть в мозги контроллера с помощью специального адаптера. 
- PWM — ШИМ генератор. Вообще это не отдельный блок, а дополнительная функция таймера, но тоже полезная. С помощью ШИМ генератора легко задать аналоговый сигнал. Например, менять яркость свечения светодиода или скорость вращения двигателя. Да мало ли куда его применить можно. Число каналов ШИМ разное от контроллера к контроллеру.

Еще бывают встроенные USB, Ethernet интерфейсы, часы реального времени, контроллеры ЖКИ дисплеев. Да чего там только нет, моделей микроконтроллеров столько, что задолбаешься только перечислять.

**Взаимодействие ядра с периферией**  
Ядро одно на всех, периферия разная. Общение между ними происходит через память. Т.е. у периферии есть свои ячейки памяти — регистры периферии. У каждого периферийного устройства их не по одной штуки. В этих регистрах находятся биты конфигурации. В зависимости от того как эти биты выставлены в таком режиме и работает периферийное устройство. В эти же регистры нужно записывать данные которые мы хотим выдать, например, по последовательному порту, или считывать данные которые обработал АЦП. Для работы с периферией есть специальные команды IN и OUT для чтения из периферии в регистр РОН и записи из регистра РОН в периферию соответственно.

Поскольку ядро одинаковое, а периферия разная, то при переносе кода на другую модель микроконтроллера надо только подправить эти обращения так как название периферийных регистров от модели к модели может чуток отличаться. Например, если в контроллере один приемопередатчик UART то регистр прием данных зовется UDR, а если два, то у нас есть уже UDR0 и UDR1. Но, в целом, все прозрачно и логично. И, как правило, портирование кода с одного МК на другой, даже если он написан на ассемблере, не составляет большого труда. Особенно если он правильно написан.

**Как узнать что есть в конкретном микроконтроллере?**  
Для этого на каждый МК есть даташит — техническая документация. И вот там, прям на первой странице, написано что почем и как. Вот тебе пример, даташит на Мегу16 с моим закадровым переводом :) Жирным шрифтом помечены опции которые я гляжу в первую очередь, как наиболее интересные для меня, остальное, как правило, присутствует по дефолту.

**Features** (фичи!)  
• High-performance, Low-power AVR® 8-bit Microcontroller  
(понтовая экономичная архитектура AVR)

• Advanced RISC Architecture  
(просто офигенная вещь для рисковых чуваков!)

– 131 Powerful Instructions – Most Single-clock Cycle Execution  
(131 крутая и быстрая команда! )

– 32 x 8 General Purpose Working Registers  
(32 восьми разрядных регистра — те самые R0…R31)

– Fully Static Operation  
(Полностью статические операции, т.е. тактовая частота может быть хоть 1 импульс в год)

– Up to 16 MIPS Throughput at 16 MHz  
(скорость выполнения до 16миллионов операций в секунду!)

– On-chip 2-cycle Multiplier  
(а числа умеем множить за два такта! Это правда круто, народ!)

• High Endurance Non-volatile Memory segments  
**– 16K Bytes of In-System Self-programmable Flash program memory**  
(памяти хватит набыдлокодить на 16кб кода)

**– 512 Bytes EEPROM 8-bit**  
(и нажрать на века 512 байт мусора в ЕЕПРОМ)

**– 1K Byte Internal SRAM**  
(оперативки 1кб, кому там 2Гигабайт не хватает? Программировать не умеете! =) Тут и 64 байтов за глаза хватает. Помните Билла Гейтса и его «640кб хватит всем!» он знал о чем говорил :)

– Write/Erase Cycles: 10,000 Flash/100,000 EEPROM Microcontroller  
(перешивать флеш можно 10тыщь раз, еепром 100тыщь раз. Так что можешь не бояться экспериментировать)

– Data retention: 20 years at 85°C/100 years at 25°C(1)  
(Если законсервируешь свой будильник на AVR, то твоих правнуков он еще и через 100 лет порадует)

– Optional Boot Code Section with Independent Lock Bits  
In-System Programming by On-chip Boot Program  
True Read-While-Write Operation  
(поддержка бутлоадеров. Удобная вещь, позволяет прошиваться без программаторов)

– Programming Lock for Software Security In-System  
(если жадный и умный, то можешь закрыть от посторонних прошивку и фиг кто выкрадет твои секреты)

• JTAG (IEEE std. 1149.1 Compliant) Interface  
– Boundary-scan Capabilities According to the JTAG Standard Programmable  
– Extensive On-chip Debug Support  
– Programming of Flash, EEPROM, Fuses, and Lock Bits through the JTAG Interface Flash  
(Отладочный интерфейс JTAG и его фичи)

• Peripheral Features  
(А вот, собственно и периферия пошла)

– Two 8-bit Timer/Counters with Separate Prescalers and Compare Modes  
(два таймера 8ми разрядных, с кучей всяких режимов разных.

– One 16-bit Timer/Counter with Separate Prescaler, Compare Mode, and Capture Mode ATmega16  
(один 16ти разрядный таймер счетчик, с кучей всяких примочек и фишек)

– Real Time Counter with Separate Oscillator  
(таймер может тикать от отдельного генератора, удобно если хочешь сделать часы)

**– Four PWM Channels ATmega16L**  
(Четыре ШИМ канала — на тех же таймерах)

**– 8-channel, 10-bit ADC**  
(восьмиканальный 10ти разрядный АЦП. Фичи его ниже)

8 Single-ended Channels  
(можно замерять по очереди сразу 8 разных напряжений)

7 Differential Channels in TQFP Package Only  
(7 дифференциальных каналов. Правда только в корпусе TQFP т.к. ног у него больше)

2 Differential Channels with Programmable Gain at 1x, 10x, or 200x  
(два дифференциальных канала с программируемым усилением)

**– Byte-oriented Two-wire Serial Interface**  
(Поддержка IIC с аппаратным кодированием байтов)

– Programmable Serial USART  
(Последовательный интерфейс. Удобен для связи с компом)

– Master/Slave SPI Serial Interface  
(SPI интерфейс, пригодится)

– Programmable Watchdog Timer with Separate On-chip Oscillator  
(Спец таймер защиты от зависаний)

– On-chip Analog Comparator  
(Тот самый компаратор)

• Special Microcontroller Features  
(полезные свистоперделки)

– Power-on Reset and Programmable Brown-out Detection  
(защита от косяков в работе при пониженном напряжении ака севшие батарейки)

**– Internal Calibrated RC Oscillator**  
(А еще можно сэкономить 20рублей на покупке внешнего кварца. Он нафиг не нужен! :) И это круто!)

– External and Internal Interrupt Sources  
(Есть внешние прерывания. Очень удобная вещь)

– Six Sleep Modes: Idle, ADC Noise Reduction, Power-save, Power-down, Standby  
and Extended Standby  
(Дофига режимов энергосбережения)

• I/O and Packages  
**– 32 Programmable I/O Lines  
– 40-pin PDIP, 44-lead TQFP, and 44-pad QFN/MLF**  
(число полезных ножек, тем самых вводов выводов)

• Operating Voltages designs.  
**– 2.7 — 5.5V for ATmega16L  
– 4.5 — 5.5V for ATmega16**  
(Питающие напряжения. Помните я говорил про низковольтные серии — вот они, во всей красе)

• Speed Grades  
**– 0 — 8 MHz for ATmega16L  
– 0 — 16 MHz for ATmega16**  
(А это максимальные частоты для разных серий. Низковольтные лажают. Впрочем, они подвержены разгону)

• Power Consumption @ 1 MHz, 3V, and 25°C for ATmega16L  
– Active: 1.1 mA  
– Idle Mode: 0.35 mA  
– Power-down Mode: < 1 µA (Потребляемая мощность в разных режимах. 1мА даже в активном режиме это фигня. В 10 раз меньше самого тухлого светодиода)