
```cpp
auto lambda = [](int param) -> int {return param * 2;};
```

# Захват переменных в лямбда-выражении

### 1. **Захват по значению (`=`)**

При захвате по значению лямбда создает копии внешних переменных, которые остаются неизменными внутри лямбды. Переменные передаются в лямбду, как если бы они были переданы по значению в обычную функцию.
```cpp
int x = 10;
auto lambda = [=]() {
    // Внутри лямбды x — это копия внешней переменной x.
    std::cout << x << std::endl;
};
x = 20;
lambda(); // Выведет 10, так как захват по значению
```

### 2. **Захват по ссылке (`&`)**

Захват по ссылке позволяет лямбде ссылаться на внешние переменные, поэтому любые изменения переменных внутри лямбды будут отражены и снаружи.
```cpp
int x = 10;
auto lambda = [&]() {
    // Внутри лямбды x — это ссылка на внешнюю переменную x.
    x = 20;
};
lambda();
std::cout << x << std::endl; // Выведет 20, так как захват по ссылке
```

### 3. **Явный захват конкретных переменных**

Вы можете явно указать, какие именно переменные захватывать, и каким способом.

- **По значению:** `[..., x]` — захват только переменной `x` по значению.
- **По ссылке:** `[&, x]` — захват `x` по значению, но остальные переменные — по ссылке.
- **Смешанный захват:** `[x, &y]` — захват `x` по значению и `y` по ссылке.
```cpp
int x = 10, y = 20;
auto lambda = [x, &y]() {
    std::cout << "x = " << x << ", y = " << y << std::endl;
};
```

### 4. **Захват всех переменных по значению или по ссылке**

Вместо захвата переменных по одной можно использовать захват всех переменных:

- `[=]` — захват всех внешних переменных по значению.
- `[&]` — захват всех внешних переменных по ссылке.
```cpp
int x = 10, y = 20;
auto lambda = [=]() {
    std::cout << x << ", " << y << std::endl;
};
```

### 5. **Перемещение переменных с помощью `std::move`**

Захват по значению создает копию переменной, но иногда может быть полезно захватить временный объект или владение уникальным ресурсом (например, `std::unique_ptr`). Для этого переменную можно захватить и сразу переместить:
```cpp
auto ptr = std::make_unique<int>(42);
auto lambda = [p = std::move(ptr)]() {
    std::cout << *p << std::endl;
};
lambda();
```

### 6. **Неявный захват и явное указание `this`**

Если в лямбде используется `[=]` или `[&]`, то члены класса по умолчанию не захватываются. Чтобы разрешить доступ к членам класса, нужно явно указать `this` в списке захвата:
```cpp
class MyClass {
public:
    int value = 10;
    auto createLambda() {
        return [=, this]() { // Захват всех внешних переменных по значению и указатель `this`
            std::cout << value << std::endl;
        };
    }
};
```

### Итого

- `[=]` и `[&]` — захват всех внешних переменных по значению или по ссылке.
- `[x, &y]` — захват переменных `x` по значению и `y` по ссылке.
- `[this]` — захват указателя на текущий объект (для доступа к членам класса).


```cpp

```