### 1. **Разделение памяти на AVR**

Микроконтроллеры AVR имеют несколько типов памяти:

- **Flash (кодовая память):** Здесь хранится прошитая программа (инструкции). Это энергонезависимая память, доступная только для чтения во время работы программы.
- **SRAM (оперативная память):** Здесь хранятся данные программы: переменные, стэк и т.д. Это энергозависимая память, доступная для записи/чтения.
- **EEPROM:** Специальная энергонезависимая память, доступная для записи/чтения, обычно используется для хранения конфигурационных данных.

Особенность в том, что память **Flash** и **SRAM** имеют **разные адресные пространства**, и компилятор C не знает, как с этим работать "из коробки". Стандарт C предполагает единую адресацию, что не соответствует аппаратным особенностям AVR.

---

### 2. **Почему возникает проблема с памятью**

Если неправильно указать область памяти, программа может работать некорректно:

- **Константы в памяти данных (SRAM):** Если константы (например, строки или таблицы данных) случайно помещаются в SRAM вместо Flash, это быстро исчерпывает ограниченные ресурсы оперативной памяти (обычно на AVR её всего 2 КБ для Uno).
    
    В таком случае оперативка забивается константами, которые могли бы находиться в энергонезависимой памяти Flash. Это приводит к переполнению SRAM и сбоям программы.
    
- **Доступ к памяти программы (Flash):** Для работы с константами, которые хранятся во Flash, требуется использовать специальные модификаторы (`PROGMEM`) и функции доступа (`pgm_read_byte`, `pgm_read_word` и т.д.), так как Flash и SRAM — это разные пространства. Без этого доступа программа может работать некорректно или зависать.
    

---

### 3. **Как избежать проблем с памятью**

Чтобы избежать путаницы и ошибок, важно понимать и использовать механизмы AVR для управления памятью:

#### **Модификатор PROGMEM**

`PROGMEM` используется для явного указания компилятору, что данные должны храниться в памяти программы (Flash), а не в SRAM.

Пример:

```c
#include <avr/pgmspace.h>

// Константный массив, хранящийся в памяти Flash
const char myString[] PROGMEM = "Hello, World!";
```

Данные из Flash нельзя использовать напрямую, поэтому для их чтения нужно использовать специальные функции:
```c
char buffer[20];
strcpy_P(buffer, myString);  // Скопировать строку из Flash в SRAM
```

#### **Функции доступа к Flash**

Если вы работаете с массивами, нужно использовать функции `pgm_read_byte` и `pgm_read_word`:
```c
#include <avr/pgmspace.h>

// Константы в памяти Flash
const uint8_t myData[] PROGMEM = {1, 2, 3, 4};

void readFlashData() {
    for (int i = 0; i < 4; i++) {
        uint8_t value = pgm_read_byte(&myData[i]);  // Чтение байта из Flash
        // Используйте значение...
    }
}
```

#### **Модификатор `F` для строк**

Если вы хотите вывести строку, хранящуюся в Flash, с использованием функции `Serial.print`, можно использовать модификатор `F`:
```c
Serial.println(F("This string is stored in Flash, not SRAM!"));
```

#### **Контроль использования памяти**

- Используйте опцию компилятора `-Wl,-Map` (Memory Map), чтобы получить карту памяти и увидеть, какие данные занимают Flash и SRAM.
- Внимательно проверяйте, где хранятся ваши переменные, особенно массивы и строки.

---

### 4. **Типовые ошибки**

#### Константы без `PROGMEM`:

```c
const char myString[] = "Hello, World!";  // Хранится в SRAM
```
В этом случае строка хранится в SRAM, что не оптимально для больших строк или массивов данных.

#### Неправильное чтение данных из Flash:

```c
char c = myString[0];  // Ошибка: доступ к Flash как к SRAM
```