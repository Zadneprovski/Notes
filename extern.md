### 1. **Объявление глобальных переменных, определённых в другом файле**  
Если у вас есть глобальная переменная в одном файле и вы хотите использовать её в другом, нужно использовать `extern`:

**Файл `file1.c`:**
```cpp
int global_var = 10;  // Определение глобальной переменной
```
**Файл `file2.c`**:
```cpp
#include <stdio.h>

extern int global_var;  // Объявление переменной

int main() {
    printf("%d\n", global_var);  // Используем переменную из file1.c
    return 0;
}

```
- Без `extern` компилятор не узнает, что `global_var` определена в `file1.c`, и выдаст ошибку.

### 2. **Использование для функций**  
- По умолчанию функции в `C` имеют `extern`-связность, но можно явно указать:

**Файл `file1.c`:**
```cpp
#include <stdio.h>

void print_message() {
    printf("Hello from file1!\n");
}
```
**Файл `file2.c`:**
```cpp
extern void print_message();  // Объявление функции

int main() {
    print_message();  // Вызываем функцию из file1.c
    return 0;
}
```
### 3. **Использование с `extern "C"` в `C++`**  
В `C++` имена функций и переменных подвергаются _name mangling_ (изменению имени), что мешает взаимодействию с кодом на `C`.  
Чтобы объявить функции или переменные, которые должны быть использованы из `C`, используют `extern "C"`:
```cpp
extern "C" {
    void c_function();  // Объявление функции, написанной на C
}
```
Внутри блока `extern "C" { }` нельзя использовать возможности `C++`, такие как:

- **Перегруженные функции**
- **Классы и объекты**
- **Шаблоны (`templates`)**
- **Перегруженные операторы**
- **Пространства имён (`namespace`)**

### Почему?

Блок `extern "C"` говорит компилятору `C++`, что всё внутри него должно соответствовать правилам языка `C`, а в `C` нет перегрузки функций, классов и прочих возможностей `C++`.

### Пример ошибки с перегрузкой:
```cpp
extern "C" {
    void foo(int x);   // OK
    void foo(double y); // Ошибка! В C нет перегрузки функций
}
```