В C++ оператор `dynamic_cast` используется для выполнения безопасного приведения типов в иерархиях классов, особенно при работе с полиморфизмом (когда класс имеет виртуальные функции). Он используется для приведения указателей или ссылок на объекты базового класса к указателям или ссылкам на производный класс, с дополнительной проверкой типа во время выполнения.

Синтаксис
```cpp
dynamic_cast<тип>(выражение)
```

### Принцип работы

1. **Приведение указателей:**
    
    - Если вы используете `dynamic_cast` с указателем на базовый класс и пытаетесь привести его к указателю на производный класс, то если объект действительно является экземпляром производного класса, преобразование выполнится успешно.
    - Если объект не принадлежит к типу, к которому вы пытаетесь привести, результатом будет `nullptr`.
2. **Приведение ссылок:**
    
    - При использовании `dynamic_cast` с ссылкой на базовый класс, если объект не принадлежит производному типу, то произойдёт исключение `std::bad_cast`.

### Пример использования:
```cpp
#include <iostream>
#include <typeinfo>

class Base {
public:
    virtual void show() { std::cout << "Base class\n"; }
    virtual ~Base() {}  // Виртуальный деструктор для полиморфизма
};

class Derived : public Base {
public:
    void show() override { std::cout << "Derived class\n"; }
};

int main() {
    Base baseObj;
    Derived derivedObj;

    // Приведение типа с базового класса к производному
    Base* basePtr = &derivedObj;
    Derived* derivedPtr = dynamic_cast<Derived*>(basePtr);

    if (derivedPtr) {
        derivedPtr->show();  // Выведет "Derived class"
    } else {
        std::cout << "Ошибка приведения типа!\n";
    }

    // Приведение типа с базового класса к производному (неудачно)
    basePtr = &baseObj;
    derivedPtr = dynamic_cast<Derived*>(basePtr);

    if (derivedPtr) {
        derivedPtr->show();
    } else {
        std::cout << "Ошибка приведения типа!\n";  // Выведет "Ошибка приведения типа!"
    }

    return 0;
}
```