### **CRC (Cyclic Redundancy Check) в Modbus RTU**

CRC (циклический избыточный код) в **Modbus RTU** используется для контроля ошибок в передаваемых данных. Он занимает **2 байта (16 бит)** и добавляется в конец каждого сообщения.

---

## **Как вычисляется CRC-16 в Modbus?**

Алгоритм основан на **делении** сообщения по модулю 2 с использованием **полинома**:

CRC16=x16+x15+x2+1CRC_{16} = x^{16} + x^{15} + x^{2} + 1CRC16​=x16+x15+x2+1

### **1. Параметры CRC-16 в Modbus:**

- **Размер**: 16 бит (2 байта)
- **Полином**: `0xA001` (обратный `0x8005`)
- **Начальное значение**: `0xFFFF`
- **Порядок обработки байтов**: **Младший байт идет первым (Little-endian)**

---

## **2. Алгоритм расчета CRC-16**

1. Установить начальное значение `CRC = 0xFFFF`.
2. Для каждого байта сообщения:
    - Выполнить `XOR` между `CRC` и байтом.
    - Пройти 8 итераций, сдвигая `CRC` вправо (LSB-first):
        - Если младший бит `CRC = 1`, выполнить `XOR` с полиномом `0xA001`.
3. После обработки всех байтов **получаем 16-битное значение CRC**.
4. **Передача CRC:**
    - **Сначала младший байт**, потом старший (Little-endian).

---

## **3. Пример расчета CRC-16 Modbus**

Допустим, у нас есть запрос на чтение данных от устройства **(Slave = 0x01, Read Holding Register, Address = 0x0001, Количество = 0x0001)**:

```
[01] [03] [00] [01] [00] [01]
```

### **Расчет CRC вручную**:

1. Начальное значение `CRC = 0xFFFF`.
2. Первый байт: `0x01` → `CRC XOR 0x01 = FFFE` → Сдвигаем 8 раз, применяем полином.
3. Повторяем процесс для всех байтов.
4. Итоговый CRC = **`0x85DB`**.

Запрос с CRC:
```
01 03 00 01 00 01 DB 85  (Little-endian: младший байт `DB`, старший `85`)
```

### **CRC-16 в Modbus RTU: Разбор принципов и вариаций**

### **1. Всегда ли CRC-16 занимает 2 байта?**

Да, **в Modbus RTU CRC всегда 16 бит (2 байта)**.  
Причины:

- Используется стандартный алгоритм **CRC-16** (16-битная контрольная сумма).
- Контрольная сумма должна быть **достаточно короткой** для быстрого вычисления, но при этом **обеспечивать надежность**.
- Для Modbus ASCII вместо CRC используется **LRC (Longitudinal Redundancy Check)** — 1 байт.

---

### **2. Почему используется полином `0xA001`?**

Полином **`0xA001`** — это обратный вариант стандартного **CRC-16 (0x8005)**:

CRC16=x16+x15+x2+1CRC_{16} = x^{16} + x^{15} + x^2 + 1CRC16​=x16+x15+x2+1

Этот полином выбран, потому что:

- **Хорошо выявляет ошибки** (особенно одиночные, двойные и групповое повреждение битов).
- **Прост в реализации** (побитовые операции XOR и сдвиги).
- **Стандарт де-факто** (используется в многих промышленных протоколах: Modbus, USB, XMODEM).

Почему `0xA001`, а не `0x8005`?

- В Modbus принято представлять полином **младшим битом вперед** (Little-endian).
- `0xA001` – это `0x8005`, но в битах развернут в обратном порядке.

---

### **3. Почему начальное значение `0xFFFF`?**

Начальное значение CRC влияет на результат вычисления.  
В Modbus выбрали `0xFFFF`, потому что:

1. **Максимизирует начальный разброс значений** (если бы старт был `0x0000`, первые несколько байтов сообщения давали бы схожие результаты).
2. **Простота реализации в микроконтроллерах** – легко записать в регистр.
3. **Соответствует стандарту CRC-16 Modbus**, принятому в 1979 году.

Некоторые другие протоколы используют `0x0000` (например, CRC в USB).

---

### **4. Почему такой алгоритм? Всегда ли он одинаковый?**

Алгоритм используется стандартный, но **есть разные реализации CRC-16**.  
Modbus RTU требует **конкретного варианта CRC-16 с Little-endian порядком байтов**.

**Другие варианты CRC-16 (с другим алгоритмом)**:

- **CRC-16-IBM** (`0x8005`, начальное `0x0000`, Big-endian)
- **CRC-16-ANSI** (тот же `0x8005`, но другие параметры)
- **CRC-16-CCITT** (`0x1021`, начальное `0xFFFF`)

Modbus **всегда использует один и тот же алгоритм**, иначе устройства не поймут друг друга.

### **Где это прописано?**

1. **Официальный стандарт Modbus**
    
    - "Modbus over Serial Line Specification & Implementation Guide"
    - "Modbus Application Protocol Specification"