
```c
volatile int i = 0;
void func0() { }
int func(int a) { return a++; }

int main(void)
{
	// 1 такт при частоте 
	//	170MHz - 5,88ns
	//	120MHz - 8,3ns
	//	48MHz - 20,8ns
	
	DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk; // Активируем CYCCNT
	DWT->CYCCNT = 0;
	i = func(i); // 32 такта -O0, 4 такта -O2
	i++; // 9 тактов -O0, 5 тактов -O2
	my_function(); // 12 тактов -O0
	
	uint32_t cycles = DWT->CYCCNT;
}
```

Регистр **DWT->CYCCNT** (Data Watchpoint and Trace Cycle Counter) в ARM Cortex-M действительно считает **точное количество тактов CPU**, но с некоторыми важными нюансами. Вот детальный разбор:

---

### 1. **Что измеряет DWT->CYCCNT?**

- Счетчик **CYCCNT** увеличивается на **1 за каждый такт системного ядра (HCLK)**.
- Это **аппаратный счетчик**, работающий на частоте CPU (например, 168 МГц для STM32F4).
- Учитывает **все такты**, включая те, когда CPU занят ожиданием (из-за branch prediction, доступа к медленной памяти и т.д.).

### 2. **Ограничения и погрешности**

#### **a) Не учитывает остановки CPU**

- Если ядро **остановлено** (например, в режиме сна или при halt отладчика), счетчик **не инкрементируется**.
- Для энергоэффективных измерений используйте **пассивные счетчики** (например, через TIMER).

#### **b) Переполнение**

- Счетчик **32-битный**, поэтому переполняется каждые:  
    $\frac{2^32 тактов}{F_{CPU}}$ ≈ 25.5 сек при 168 МГц.
#### **c) Влияние прерываний**

- Если во время измерения происходит **прерывание**, счетчик продолжает считать такты обработчика.
- Для чистых измерений **отключайте прерывания** на критических участках

### **Микросекундные задержки**
```c
void delay_us(uint32_t microseconds) {
    uint32_t start = DWT->CYCCNT;
    // Конвертация мкс в такты
    uint32_t ticks = microseconds * (SystemCoreClock / 1000000); 
    while ((DWT->CYCCNT - start) < ticks);
}
```