### 1. **Использование `constexpr`:**

`constexpr` — это основное средство, которое заставляет компилятор вычислять выражение на этапе компиляции, если это возможно.

- **Функции** с ключевым словом `constexpr` могут быть выполнены на этапе компиляции, если все аргументы являются константными выражениями.
- **Переменные** могут быть объявлены как `constexpr`, если их значения могут быть вычислены на этапе компиляции.

Например:

```cpp
constexpr int square(int x) {
    return x * x;
}

constexpr int result = square(5);  // Вычисляется на этапе компиляции
```

**Если все входные значения константные**, компилятор вычислит результат на этапе компиляции. Если хоть одно значение будет известно только на этапе выполнения, функция `square` будет выполнена уже во время выполнения программы.

**Как проверить:** Чтобы быть уверенным, что `constexpr` функция действительно выполняется на этапе компиляции, можно попробовать объявить её результат как `constexpr` переменную. Если компилятор может вывести значение переменной, то вычисление действительно происходит на этапе компиляции. Если нет — компилятор выдаст ошибку.

### 2. **Использование `consteval`:**

C++20 добавил ключевое слово `consteval`, которое гарантирует, что выражение должно быть **обязательно вычислено на этапе компиляции**, иначе это приведёт к ошибке компиляции.

Пример:

```cpp
consteval int factorial(int n) {
    return (n <= 1) ? 1 : (n * factorial(n - 1));
}

int main() {
    constexpr int fact = factorial(5);  // Обязательно на этапе компиляции
    int runtime_fact = factorial(5); // Ошибка: это должно быть вычислено на этапе компиляции
}
```

В отличие от `constexpr`, `consteval` функции **не могут** быть вызваны во время выполнения. Любой вызов `consteval` функции с динамическими (неизвестными на этапе компиляции) аргументами приведёт к ошибке компиляции.