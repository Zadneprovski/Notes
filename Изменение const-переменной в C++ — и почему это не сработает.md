## Почему `const_cast` (и C-style cast) не работают с `const int`?

### Проблема

Рассмотрим следующий пример:

```cpp
#include <iostream>

int main() {
    const int x = 7;
    int* hack = const_cast<int*>(&x);
    *hack = 1;
    std::cout << x;
    return 0;
}
```
Многие ожидают, что эта программа выведет `1`. Однако на практике она чаще всего выведет `7`. Иногда — даже может упасть. Почему?

### Разбор

Ключевой момент — строка `const int x = 7;`. Это не просто переменная, которую нельзя изменить. Это указание компилятору, что **значение известно на этапе компиляции** и **никогда не изменится**.

Компилятор вправе:

- Заменить `x` на `7` везде, где используется,
- Не выделять под `x` память вовсе,
- Поместить `x` в read-only сегмент памяти.

### Почему не сработало изменение через `const_cast`?
```cpp
int* hack = const_cast<int*>(&x);
*hack = 1;
```
Такой код формально допустим — он компилируется. Но результат — **неопределённое поведение** (undefined behavior), потому что вы пытаетесь изменить объект, изначально объявленный как `const`.

> **Важно:** даже если использовать C-style cast:
```cpp
int* hack = (int*)&x;
*hack = 1;
```
> — поведение остаётся **неопределённым**. C-style cast делает то же самое, что `const_cast`, и не «умнее» его.

### Почему выводится `7`, а не `1`?

Компилятор просто вставил `7` напрямую в `std::cout << x;`, потому что `x` — `const`. То, что вы меняете память, уже никак не влияет на поведение этой строки — она вообще может не обращаться к `x` в памяти.

### Когда `const_cast` всё-таки работает?

Когда объект **не является `const` изначально**, но доступен через `const`-ссылку или указатель:
```cpp
int x = 7;
const int& cx = x;
int* hack = const_cast<int*>(&cx);
*hack = 1;
std::cout << x; // Выведет 1 — поведение определено
```
